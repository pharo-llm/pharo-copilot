"
Builds completion result sets using suggestions generated by the Ollama API.

"
Class {
	#name : 'CoPharoCopilotResultSetBuilder',
	#superclass : 'CoResultSetBuilder',
	#category : 'AI-Pharo-Copilot',
	#package : 'AI-Pharo-Copilot'
}

{ #category : 'instance creation' }
CoPharoCopilotResultSetBuilder class >> initializeOnContext: aSystemCompletionContext [ 
    ^ self new
        initializeOnContext: aSystemCompletionContext;
        yourself
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> buildCompletion [

        | prefix suffix client content fetcher rawResponse rawResponseString contextInfo |
        prefix := completionContext source copyFrom: 1 to: completionContext position.
        suffix := completionContext position < completionContext source size
                          ifTrue: [ completionContext source copyFrom: completionContext position + 1 to: completionContext source size ]
                          ifFalse: [ '' ].
        contextInfo := Dictionary new
                at: #contextClass put: completionContext class name;
                at: #cursorPosition put: completionContext position;
                at: #sourceSize put: completionContext source size;
                at: #fullSource put: completionContext source;
                at: #prefix put: prefix;
                at: #suffix put: suffix;
                yourself.
        CoCopilotLogger
                logFrontEndEvent: 'Preparing completion request'
                details: contextInfo.

        client := OllamaClient new.
        rawResponse := client generateForPrefix: prefix suffix: suffix.
        rawResponseString := [ rawResponse asString ]
                on: Error
                do: [ rawResponse printString ].
        CoCopilotLogger
                logBackEndEvent: 'Received raw suggestion payload'
                details: (Dictionary new
                        at: #rawResponseClass put: rawResponse class name;
                        at: #rawResponse put: rawResponseString;
                        yourself).
        content := rawResponseString.
        [
                | parsed |
                parsed := STONJSON fromString: rawResponseString.
                (parsed isKindOf: Dictionary) ifTrue: [
                        content := parsed at: #response ifAbsent: [ parsed at: 'response' ifAbsent: [ rawResponseString ] ] ] ]
                on: Error
                do: [ :ex |
                        CoCopilotLogger
                                logBackEndEvent: 'Failed to parse suggestion payload as JSON'
                                details: (Dictionary new
                                        at: #error put: ex messageText;
                                        at: #rawResponse put: rawResponseString;
                                        yourself) ].

	        content := self cleanedContentFrom: content asString.
        CoCopilotLogger
                logBackEndEvent: 'Normalized suggestion content'
                details: (Dictionary new
                        at: #cleanedContent put: content;
                        at: #cleanedLength put: content size;
                        yourself).

	        content isEmpty
                ifFalse: [
                        completionContext replaceTokenInEditorWith: content.
                        CoCopilotLogger
                                logFrontEndEvent: 'Applied suggestion to editor'
                                details: (Dictionary new
                                        at: #appliedContent put: content;
                                        at: #appliedLength put: content size;
                                        yourself) ]
                ifTrue: [
                        CoCopilotLogger
                                logFrontEndEvent: 'No suggestion content to apply'
                                details: (Dictionary new
                                        at: #reason put: 'Generated content was empty';
                                        at: #rawResponse put: rawResponseString;
                                        yourself) ].

	fetcher := CoCollectionFetcher onCollection: #(  ).
	^ CoResultSet fetcher: fetcher
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> cleanedContentFrom: aString [

	| start end delimiter idx segment firstLine |
	start := aString indexOfSubCollection: '```' startingAt: 1 ifAbsent: [ 0 ].
	start > 0 ifTrue: [
			end := aString indexOfSubCollection: '```' startingAt: start + 3 ifAbsent: [ aString size + 1 ].
			segment := aString copyFrom: start + 3 to: end - 1.
			idx := segment indexOf: Character lf ifAbsent: [ 0 ].
			idx > 0 ifTrue: [
					firstLine := segment copyFrom: 1 to: idx - 1.
					(firstLine isEmpty or: [ self isLanguageSpec: firstLine ]) ifTrue: [ segment := segment copyFrom: idx + 1 to: segment size ] ].
			^ segment trimBoth ].
	delimiter := String lf , String lf.
	idx := aString indexOfSubCollection: delimiter startingAt: 1 ifAbsent: [ 0 ].
	segment := idx = 0
		           ifTrue: [ aString ]
		           ifFalse: [ aString copyFrom: 1 to: idx - 1 ].
	^ segment trimBoth
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> initializeOnContext: aSystemCompletionContext [ 

    completionContext := aSystemCompletionContext
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> isLanguageSpec: aString [

| known |
known := #(
'smalltalk' 'pharo' 'bash' 'sh' 'shell' 'python'
'javascript' 'json' 'java' 'c' 'cpp' 'xml' 'html'
'ruby' 'php' 'sql' 'yaml' 'yml' ).
^ known includes: aString asLowercase
]
