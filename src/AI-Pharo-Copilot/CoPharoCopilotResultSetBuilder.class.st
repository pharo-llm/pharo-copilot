"
Builds completion result sets using suggestions generated by the Ollama API.

"
Class {
	#name : 'CoPharoCopilotResultSetBuilder',
	#superclass : 'CoResultSetBuilder',
	#instVars : [
		'debounceProcess',
		'debounceToken',
		'debounceMilliseconds',
		'idleMilliseconds',
		'classContextCache'
	],
	#category : 'AI-Pharo-Copilot',
	#package : 'AI-Pharo-Copilot'
}

{ #category : 'instance creation' }
CoPharoCopilotResultSetBuilder class >> initializeOnContext: aSystemCompletionContext [

	"Create and initialize a builder bound to the given completion context."
	^ self new
		initializeOnContext: aSystemCompletionContext;
		yourself
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> applyContent: contentString toContext: aContext expectedPrefix: expectedPrefix suffix: expectedSuffix contextInfo: contextInfo [
	"Never delete user-typed text. Prefer INSERT at caret; fallback to safe append."

	| snapshot currentPrefix currentSuffix source pos inserted |
	contentString isEmpty ifTrue: [ ^ self ].
	aContext ifNil: [ ^ self ].

	snapshot := self contextSnapshotFor: aContext.
	currentPrefix := snapshot at: #prefix.
	currentSuffix := snapshot at: #suffix.

	((currentPrefix = expectedPrefix) and: [ currentSuffix = expectedSuffix ]) ifFalse: [ ^ self ].

	"1) Best case: insert at caret (Copilot-like behavior: user's text stays)."
	inserted := false.
	self deferUI: [
		inserted := self insertAtCaretIfPossibleIn: aContext text: contentString
	].

	inserted ifTrue: [ ^ self ].

	"2) Fallback: append without rewriting what user already typed (safe)."
	source := [ aContext source ifNil: [ '' ] ] on: Error do: [ '' ].
	pos := [ aContext position ifNil: [ 0 ] ] on: Error do: [ 0 ].
	pos := (pos max: 0) min: source size.

	"Only do fallback when cursor is NOT inside a word (avoid corrupting)."
	(pos < source size and: [ (self isWordChar: (source at: pos)) and: [ self isWordChar: (source at: pos + 1) ] ])
		ifTrue: [ ^ self ].

	self deferUI: [
		aContext replaceTokenInEditorWith: (contentString "replace token only when we cannot insert")
	]
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> buildCompletion [
	"Only schedule when we're at a word boundary (or idle after finishing a word)."

	| context pair source pos delay snapshot prefix suffix contextInfo fetcher |
	context := completionContext.

	(self shouldRequestCompletionForContext: context) ifFalse: [
		fetcher := CoCollectionFetcher onCollection: #().
		^ CoResultSet fetcher: fetcher
	].

	pair := self safeSourceAndPositionFor: context.
	source := pair first.
	pos := pair second.

	delay := self requestDelayForSource: source position: pos.

	"Only now take the full snapshot (prefix/suffix copies) — not on every keystroke."
	snapshot := self contextSnapshotFor: context.
	prefix := snapshot at: #prefix.
	suffix := snapshot at: #suffix.

	contextInfo := self contextInfoFor: context prefix: prefix suffix: suffix.

	self
		scheduleCompletionFor: context
		prefix: prefix
		suffix: suffix
		contextInfo: contextInfo
		delayMilliseconds: delay.

	fetcher := CoCollectionFetcher onCollection: #().
	^ CoResultSet fetcher: fetcher
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> classContextFor: aContext prefix: prefixString [ 

	| behavior extractor ast compiledMethod methodClass selector stamp cached builder context classDefinition instanceSide classSide |
	behavior := aContext completionClass.
	extractor := CNSelectorExtractor new.
	ast := OCParser parseFaultyMethod: prefixString.
	selector := extractor extractSelectorFromAST: ast atPosition: 1.
	compiledMethod := behavior compiledMethodAt: selector.
	methodClass := compiledMethod methodClass.

	classContextCache ifNil: [ classContextCache := Dictionary new ].

	stamp := self classStampFor: methodClass.
	cached := classContextCache at: methodClass ifAbsent: [ nil ].
	(cached notNil and: [ (cached at: #stamp ifAbsent: [ #(0 0) ]) = stamp ]) ifTrue: [
		^ cached at: #context ifAbsent: [ '' ]
	].

	builder := selector ifNotNil: [ CopilotContextFactory forSelector: selector ].
	builder ifNotNil: [
		context := builder buildForFIMWithPrefix: prefixString.
		classContextCache at: methodClass put: (Dictionary new
			at: #stamp put: stamp;
			at: #context put: context;
			yourself).
		^ context
	].

	classDefinition := self safeDefinitionStringFor: methodClass.

	"Limit methods hard — you can tune these numbers."
	instanceSide := self methodSourcesFor: methodClass around: selector limit: 30.
	classSide := self methodSourcesFor: (methodClass ifNotNil: [ methodClass class ]) around: nil limit: 15.

	context := self
		classDefinition: classDefinition
		instanceMethods: instanceSide
		classMethods: classSide.

	classContextCache at: methodClass put: (Dictionary new
		at: #stamp put: stamp;
		at: #context put: context;
		yourself).

	^ context
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> classDefinition: classDefinitionString instanceMethods: instanceMethodsString classMethods: classMethodsString [
	"Format the class context (definition and methods) into a single string suitable for passing to the model."

	| hasDefinition hasInstance hasClass |
	hasDefinition := classDefinitionString isEmpty not.
	hasInstance := instanceMethodsString isEmpty not.
	hasClass := classMethodsString isEmpty not.

	(hasDefinition or: [ hasInstance or: hasClass ]) ifFalse: [ ^ '' ].

	^ String streamContents: [ :stream |
		hasDefinition ifTrue: [
			stream
				nextPutAll: 'Class Definition:';
				cr;
				nextPutAll: classDefinitionString;
				cr;
				cr ].

		hasInstance ifTrue: [
			stream
				nextPutAll: 'Instance Side Methods:';
				cr;
				nextPutAll: instanceMethodsString;
				cr ].

		hasClass ifTrue: [
			stream
				nextPutAll: 'Class Side Methods:';
				cr;
				nextPutAll: classMethodsString ] ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> classStampFor: aBehavior [

	"Cheap stamp: changes when methodDict is replaced or selector count changes."
	aBehavior ifNil: [ ^ #(0 0) ].
	^ { aBehavior methodDict identityHash. aBehavior selectors size }
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> cleanedContentFrom: aString [
	"Normalize suggestion text: prefer code-fence body if present, drop language markers, trim surrounding whitespace."

	| text fenceStart rest fenceEnd body newlineIndex firstLine delimiterIndex |
	text := (aString ifNil: [ '' ]) asString.
	text isEmpty ifTrue: [ ^ '' ].

	fenceStart := text indexOfSubCollection: '```' startingAt: 1 ifAbsent: [ 0 ].
	fenceStart > 0 ifTrue: [
		rest := (fenceStart + 3 <= text size)
			ifTrue: [ text copyFrom: fenceStart + 3 to: text size ]
			ifFalse: [ '' ].

		fenceEnd := self indexOfClosingFenceIn: rest startingAt: 1.
		fenceEnd := fenceEnd = 0
			ifTrue: [ rest size + 1 ]
			ifFalse: [ fenceEnd ].

		body := fenceEnd <= 1
			ifTrue: [ '' ]
			ifFalse: [ rest copyFrom: 1 to: fenceEnd - 1 ].

		"Drop a first-line language spec like ```smalltalk"
		newlineIndex := body indexOf: Character lf ifAbsent: [ 0 ].
		newlineIndex > 0 ifTrue: [
			firstLine := body copyFrom: 1 to: newlineIndex - 1.
			((firstLine isEmpty) or: [ self isLanguageSpec: firstLine ]) ifTrue: [
				body := newlineIndex < body size
					ifTrue: [ body copyFrom: newlineIndex + 1 to: body size ]
					ifFalse: [ '' ] ] ]
		ifFalse: [
			(self isLanguageSpec: body) ifTrue: [ body := '' ] ].

		^ body trimBoth
	].

	"Fallback: keep only the first paragraph if multiple paragraphs exist."
	delimiterIndex := text indexOfSubCollection: (String lf , String lf) startingAt: 1 ifAbsent: [ 0 ].
	body := delimiterIndex = 0
		ifTrue: [ text ]
		ifFalse: [ text copyFrom: 1 to: delimiterIndex - 1 ].

	^ body trimBoth
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> contextInfoFor: aContext prefix: prefixString suffix: suffixString [
	"Build a diagnostic payload used for logging and debugging completion requests."

	^ Dictionary new
		at: #contextClass put: aContext class name;
		at: #cursorPosition put: aContext position;
		at: #sourceSize put: aContext source size;
		at: #fullSource put: aContext source;
		at: #prefix put: prefixString;
		at: #suffix put: suffixString;
		yourself
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> contextSnapshotFor: aContext [
	"Take a safe snapshot (prefix/suffix/position) of the completion context so we can detect changes."

	| source position |
	source := [ aContext source ifNil: [ '' ] ] on: Error do: [ '' ].
	position := [ aContext position ifNil: [ 0 ] ] on: Error do: [ 0 ].
	position := (position max: 0) min: source size.

	^ Dictionary new
		at: #prefix put: (position > 0
			ifTrue: [ source copyFrom: 1 to: position ]
			ifFalse: [ '' ]);
		at: #suffix put: (position < source size
			ifTrue: [ source copyFrom: position + 1 to: source size ]
			ifFalse: [ '' ]);
		at: #position put: position;
		at: #sourceLength put: source size;
		yourself
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> debounceMilliseconds [

	^ debounceMilliseconds ifNil: [ CopilotSettings completionDebounceMilliseconds ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> debounceMilliseconds: anInteger [
	"Set the debounce delay (milliseconds) used before firing a completion request."

	debounceMilliseconds := self normalizedDelayMilliseconds: anInteger default: CopilotSettings completionDebounceMilliseconds
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> deferUI: aBlock [

	"Best-effort: run editor mutation on UI process."
	| uiClass ui |
	uiClass := Smalltalk globals at: #UIManager ifAbsent: [ nil ].
	(uiClass notNil and: [ uiClass respondsTo: #default ]) ifTrue: [
		ui := uiClass default.
		(ui respondsTo: #defer:) ifTrue: [ ^ ui defer: aBlock ].
	].

	^ aBlock value
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> ebounceMilliseconds [
	"Return the current debounce delay used before firing a completion request."

	^ debounceMilliseconds ifNil: [ 250 ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> extractResponseContentFromRaw: rawResponseString [
	"Extract the suggestion text from the raw Ollama payload (JSON or plain text)."

	| content |
	content := rawResponseString.

	[
		| parsed |
		parsed := STONJSON fromString: rawResponseString.
		(parsed isKindOf: Dictionary) ifTrue: [
			content := parsed
				at: #response
				ifAbsent: [ parsed at: 'response' ifAbsent: [ rawResponseString ] ] ]
	]
		on: Error
		do: [ :ex |
			CoCopilotLogger
				logBackEndEvent: 'Failed to parse suggestion payload as JSON'
				details: (Dictionary new
					at: #error put: ex messageText;
					at: #rawResponse put: rawResponseString;
					yourself) ].

	^ content asString
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> idleMilliseconds [
	"Idle delay used when user finishes a word and pauses."

	^ idleMilliseconds ifNil: [ CopilotSettings completionIdleMilliseconds]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> idleMilliseconds: anInteger [

	idleMilliseconds := self normalizedDelayMilliseconds: anInteger default: CopilotSettings completionIdleMilliseconds
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> indexOfClosingFenceIn: text startingAt: startIndex [
	"Return the index of the last valid closing ``` fence in text (must be on its own line-ish); 0 if none."

	| idx lastValid size |
	text isEmpty ifTrue: [ ^ 0 ].

	size := text size.
	lastValid := 0.
	idx := text indexOfSubCollection: '```' startingAt: startIndex ifAbsent: [ 0 ].

	[ idx > 0 ] whileTrue: [
		| before after |
		before := (idx = 1)
			or: [ | prev |
				prev := text at: idx - 1.
				(prev = Character lf) or: [ prev = Character cr ] ].

		after := (idx + 3 > size)
			or: [ | next |
				next := text at: idx + 3.
				(next = Character lf) or: [ next = Character cr ] ].

		(before and: after) ifTrue: [ lastValid := idx ].
		idx := text indexOfSubCollection: '```' startingAt: idx + 1 ifAbsent: [ 0 ].
	].

	^ lastValid
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> initialize [
	"Initialize default debounce settings."

	super initialize.
	debounceToken := 0
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> initializeOnContext: aSystemCompletionContext [
	"Bind this builder to a completion context provided by the completion system."

	completionContext := aSystemCompletionContext
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> insertAtCaretIfPossibleIn: aContext text: aString [
	"Try hard to INSERT (not replace) so user text is never deleted."

	| editor |

	(aString isNil or: [ aString isEmpty ]) ifTrue: [ ^ false ].
	(aContext respondsTo: #editor) ifFalse: [ ^ false ].

	editor := [ aContext editor ] on: Error do: [ nil ].
	editor ifNil: [ ^ false ].

	"Preferred: real insertion at caret"
	(editor respondsTo: #addString:) ifTrue: [
		editor addString: aString.
		^ true
	].

	"Fallback: replace empty selection only"
	(editor respondsTo: #selectionInterval)
		ifTrue: [
			editor selectionInterval isEmpty ifTrue: [
				editor replaceSelectionWith: aString.
				^ true
			]
		].

	^ false

]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> isLanguageSpec: aString [
	"Answer true if the string looks like a code-fence language marker (e.g., 'smalltalk', 'pharo', 'json')."

	| candidate trimmed |
	aString ifNil: [ ^ false ].

	candidate := aString asString.
	candidate isEmpty ifTrue: [ ^ false ].

	trimmed := candidate trimBoth.
	(trimmed size = candidate size) ifFalse: [ ^ false ].
	candidate := trimmed.

	^ (#('smalltalk' 'pharo' 'bash' 'sh' 'shell' 'python'
		'javascript' 'json' 'java' 'c' 'cpp' 'xml' 'html'
		'ruby' 'php' 'sql' 'yaml' 'yml' 'go' 'rust' 'typescript')
		includes: candidate asLowercase)
		or: [ candidate allSatisfy: [ :ch |
			ch isLetter
				or: [ ch isDigit
				or: [ '#+-_' includes: ch ] ] ] ]
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> isTriggerBoundaryChar: ch [
	"Characters that indicate a boundary (space/newline/punct)."
	ch ifNil: [ ^ true ].
	(ch isSeparator) ifTrue: [ ^ true ].
	^ '.;:,()[]{}' includes: ch
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> isWordChar: ch [

	ch ifNil: [ ^ false ].
	^ ch isLetter
		or: [ ch isDigit
		or: [ ch = $_ ] ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> methodSourcesFor: aBehavior [
	"Collect and concatenate the source of all methods of the given behavior (sorted), ignoring failures."

	aBehavior ifNil: [ ^ '' ].

	^ String streamContents: [ :stream |
		[
			(aBehavior selectors asSortedCollection) do: [ :selector |
				| source |
				source := [ aBehavior sourceCodeAt: selector ] on: Error do: [ nil ].
				source ifNotNil: [
					stream
						nextPutAll: source;
						cr;
						cr ] ] ]
			on: Error
			do: [ ] ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> methodSourcesFor: aBehavior around: aSelector limit: limitInteger [ 

	"Only a window of methods; avoids huge prompt building."
	| sorted idx half start end |
	aBehavior ifNil: [ ^ '' ].

	sorted := aBehavior selectors asSortedCollection asArray.
	sorted isEmpty ifTrue: [ ^ '' ].

	idx := (aSelector isNil)
		ifTrue: [ 1 ]
		ifFalse: [ sorted indexOf: aSelector ifAbsent: [ 1 ] ].

	half := limitInteger // 2.
	start := (idx - half) max: 1.
	end := (start + limitInteger - 1) min: sorted size.
	start := (end - limitInteger + 1) max: 1.

	^ String streamContents: [ :stream |
		(start to: end) do: [ :i |
			| sel src |
			sel := sorted at: i.
			src := [ aBehavior sourceCodeAt: sel ] on: Error do: [ nil ].
			src ifNotNil: [
				stream nextPutAll: src; cr; cr ] ] ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> minimumPrefixLength [
	"Minimum prefix length required before we request a completion."

	^ 2
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> normalizedDelayMilliseconds: anObject default: defaultValue [
	"Normalize a delay, enforcing a non-zero millisecond range."

	| candidate |
	anObject ifNil: [ ^ defaultValue ].
	candidate := [ anObject asInteger ] on: Error do: [ defaultValue ].
	candidate <= 0 ifTrue: [ ^ defaultValue ].
	candidate := candidate max: 1.
	^ candidate min: 60000
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> processCompletionFor: aContext prefix: prefixString suffix: suffixString contextInfo: contextInfo [
	"Call Ollama, normalize the response into plain text, then apply it if the editor context is unchanged."

	| classContext |
	[
		| client rawResponse rawResponseString content |
		CoCopilotLogger logFrontEndEvent: 'Preparing completion request' details: contextInfo.

		client := OllamaClient new.
		classContext := self classContextFor: aContext prefix: prefixString.

		contextInfo
			at: #classContextLength put: classContext size;
			at: #classContextPresent put: classContext isEmpty not.
			
		self haltOnce.

		rawResponse := client generateForPrefix: prefixString suffix: suffixString context: classContext.

		rawResponseString := [ rawResponse asString ]
			on: Error
			do: [ rawResponse printString ].

		CoCopilotLogger
			logBackEndEvent: 'Received raw suggestion payload'
			details: (Dictionary new
				at: #rawResponseClass put: rawResponse class name;
				at: #rawResponse put: rawResponseString;
				yourself).

		contextInfo at: #rawResponse put: rawResponseString.

		content := self extractResponseContentFromRaw: rawResponseString.
		content := self cleanedContentFrom: content.

		CoCopilotLogger
			logBackEndEvent: 'Normalized suggestion content'
			details: (Dictionary new
				at: #cleanedContent put: content;
				at: #cleanedLength put: content size;
				yourself).

		self
			applyContent: content
			toContext: aContext
			expectedPrefix: prefixString
			suffix: suffixString
			contextInfo: contextInfo
	]
		on: Error
		do: [ :ex |
			CoCopilotLogger
				logError: 'Asynchronous completion failed'
				origin: #CoPharoCopilotResultSetBuilder
				exception: ex
				payload: (Dictionary new
					at: #requestDetails put: contextInfo copy;
					at: #prefixLength put: prefixString size;
					at: #suffixLength put: suffixString size;
					yourself) ]
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> requestDelayForSource: source position: pos [
	| before |
	before := pos > 0 ifTrue: [ source at: pos ] ifFalse: [ nil ].

	"Fast when user just hit a boundary (like space)."
	(self isTriggerBoundaryChar: before) ifTrue: [ ^ self debounceMilliseconds ].

	"Otherwise wait for real idle."
	^ self idleMilliseconds
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> safeDefinitionStringFor: aBehavior [
	"Return the class definition string for a behavior, or empty string if unavailable."

	aBehavior ifNil: [ ^ '' ].
	^ [ aBehavior definition asString ] on: Error do: [ '' ]
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> safeSourceAndPositionFor: aContext [
	| source pos |
	source := [ aContext source ifNil: [ '' ] ] on: Error do: [ '' ].
	pos := [ aContext position ifNil: [ 0 ] ] on: Error do: [ 0 ].
	pos := (pos max: 0) min: source size.
	^ { source. pos }
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> scheduleCompletionFor: aContext prefix: prefixString suffix: suffixString contextInfo: contextInfo [
	^ self
		scheduleCompletionFor: aContext
		prefix: prefixString
		suffix: suffixString
		contextInfo: contextInfo
		delayMilliseconds: self debounceMilliseconds
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> scheduleCompletionFor: aContext prefix: prefixString suffix: suffixString contextInfo: contextInfo delayMilliseconds: delayMs [
	"Debounce: cancel pending, schedule only latest."

	| token priority |
	debounceToken ifNil: [ debounceToken := 0 ].
	debounceToken := debounceToken + 1.
	token := debounceToken.

	debounceProcess ifNotNil: [ debounceProcess terminate ].

	priority := (Processor class includesSelector: #userSchedulingPriority)
		ifTrue: [ Processor userSchedulingPriority ]
		ifFalse: [ Processor userBackgroundPriority ].

	debounceProcess := [
		(Delay forMilliseconds: delayMs) wait.
		token = debounceToken ifTrue: [
			self
				processCompletionFor: aContext
				prefix: prefixString
				suffix: suffixString
				contextInfo: contextInfo ] ] forkAt: priority
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> shouldRequestCompletionForContext: aContext [
	"NO trigger while cursor is inside the same word."
	| pair source pos before after |
	aContext ifNil: [ ^ false ].

	pair := self safeSourceAndPositionFor: aContext.
	source := pair first.
	pos := pair second.

	(pos < self minimumPrefixLength) ifTrue: [ ^ false ].

	before := pos > 0 ifTrue: [ source at: pos ] ifFalse: [ nil ].
	after := pos < source size ifTrue: [ source at: pos + 1 ] ifFalse: [ nil ].

	"Cursor inside a word => do NOT initialize completion engine."
	((self isWordChar: before) and: [ self isWordChar: after ]) ifTrue: [ ^ false ].

	^ true
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> shouldRequestCompletionForPrefix: prefixString suffix: suffixString [
	"Decide whether it's worth requesting a completion for the current prefix/suffix."

	prefixString ifNil: [ ^ false ].
	(prefixString size < self minimumPrefixLength) ifTrue: [ ^ false ].
	^ true
]
