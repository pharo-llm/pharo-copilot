"
Builds completion result sets using suggestions generated by the Ollama API.

"
Class {
	#name : 'CoPharoCopilotResultSetBuilder',
	#superclass : 'CoResultSetBuilder',
	#instVars : [
		'debounceProcess',
		'debounceToken',
		'debounceMilliseconds'
	],
	#category : 'AI-Pharo-Copilot',
	#package : 'AI-Pharo-Copilot'
}

{ #category : 'instance creation' }
CoPharoCopilotResultSetBuilder class >> initializeOnContext: aSystemCompletionContext [ 
    ^ self new
        initializeOnContext: aSystemCompletionContext;
        yourself
]

{ #category : 'private' }
CoPharoCopilotResultSetBuilder >> applyContent: content toContext: aContext expectedPrefix: prefixString suffix: suffixString contextInfo: contextInfo [

	| snapshot |
	content isEmpty ifTrue: [ ^ self ].
	aContext ifNil: [ ^ self ].
	snapshot := self contextSnapshotFor: aContext.
	((snapshot at: #prefix) = prefixString and: [ (snapshot at: #suffix) = suffixString ]) ifFalse: [ ^ self ].
	aContext replaceTokenInEditorWith: content.
	^ self.
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> buildCompletion [

        | context prefix suffix contextInfo fetcher |
        context := completionContext.
        prefix := context source copyFrom: 1 to: context position.
        suffix := context position < context source size
                          ifTrue: [ context source copyFrom: context position + 1 to: context source size ]
		          ifFalse: [ '' ].
	contextInfo := Dictionary new
		               at: #contextClass put: context class name;
		               at: #cursorPosition put: context position;
		               at: #sourceSize put: context source size;
		               at: #fullSource put: context source;
		               at: #prefix put: prefix;
		               at: #suffix put: suffix;
		               yourself.
		        (self shouldRequestCompletionForPrefix: prefix suffix: suffix)
                ifTrue: [ self scheduleCompletionFor: context prefix: prefix suffix: suffix contextInfo: contextInfo ].


	fetcher := CoCollectionFetcher onCollection: #(  ).
	^ CoResultSet fetcher: fetcher
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> classContextFor: aContext [

        | behavior compiledMethod methodClass classDefinition instanceSide classSide |
        behavior := (aContext respondsTo: #behavior)
                ifTrue: [ [ aContext behavior ] on: Error do: [ nil ] ]
                ifFalse: [ nil ].
        compiledMethod := (aContext respondsTo: #method)
                ifTrue: [ [ aContext method ] on: Error do: [ nil ] ]
                ifFalse: [ nil ].
        methodClass := behavior ifNil: [ compiledMethod ifNotNil: [ compiledMethod methodClass ] ] ifNotNil: [ behavior ].
        classDefinition := self safeDefinitionStringFor: methodClass.
        instanceSide := self methodSourcesFor: methodClass.
        classSide := self methodSourcesFor: (methodClass ifNotNil: [ methodClass class ]).
        ^ self
                classDefinition: classDefinition
                instanceMethods: instanceSide
                classMethods: classSide
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> classDefinition: classDefinitionString instanceMethods: instanceMethodsString classMethods: classMethodsString [

        | hasDefinition hasInstance hasClass |
        hasDefinition := classDefinitionString isEmpty not.
        hasInstance := instanceMethodsString isEmpty not.
        hasClass := classMethodsString isEmpty not.
        (hasDefinition or: [ hasInstance or: hasClass ]) ifFalse: [ ^ '' ].
        ^ String streamContents: [ :stream |
                hasDefinition ifTrue: [
                        stream
                                nextPutAll: 'Class Definition:';
                                cr;
                                nextPutAll: classDefinitionString;
                                cr;
                                cr ].
                hasInstance ifTrue: [
                        stream
                                nextPutAll: 'Instance Side Methods:';
                                cr;
                                nextPutAll: instanceMethodsString;
                                cr ].
                hasClass ifTrue: [
                        stream
                                nextPutAll: 'Class Side Methods:';
                                cr;
                                nextPutAll: classMethodsString ] ]
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> cleanedContentFrom: aString [

	| text start rest closingIndex body newlineIndex firstLine delimiter idx |
        text := (aString ifNil: [ '' ]) asString.
        text isEmpty ifTrue: [ ^ '' ].

        start := text indexOfSubCollection: '```' startingAt: 1 ifAbsent: [ 0 ].
        start > 0 ifTrue: [
                rest := start + 3 <= text size
                        ifTrue: [ text copyFrom: start + 3 to: text size ]
                        ifFalse: [ '' ].
                closingIndex := self indexOfClosingFenceIn: rest startingAt: 1.
                closingIndex := closingIndex = 0
                        ifTrue: [ rest size + 1 ]
                        ifFalse: [ closingIndex ].
                body := closingIndex <= 1
                        ifTrue: [ '' ]
                        ifFalse: [ rest copyFrom: 1 to: closingIndex - 1 ].
                newlineIndex := body indexOf: Character lf ifAbsent: [ 0 ].
                newlineIndex > 0
                        ifTrue: [
                                firstLine := body copyFrom: 1 to: newlineIndex - 1.
                                (firstLine isEmpty or: [ self isLanguageSpec: firstLine ]) ifTrue: [
                                        body := newlineIndex < body size
                                                ifTrue: [ body copyFrom: newlineIndex + 1 to: body size ]
                                                ifFalse: [ '' ] ] ]
                        ifFalse: [
                                (self isLanguageSpec: body) ifTrue: [ body := '' ] ].
                ^ body trimBoth ].

        delimiter := String lf , String lf.
        idx := text indexOfSubCollection: delimiter startingAt: 1 ifAbsent: [ 0 ].
        body := idx = 0
                        ifTrue: [ text ]
                        ifFalse: [ text copyFrom: 1 to: idx - 1 ].
        ^ body trimBoth
]

{ #category : 'validation' }
CoPharoCopilotResultSetBuilder >> contextSnapshotFor: aContext [

        | safeSource safePosition |
        safeSource := [ aContext source ifNil: [ '' ] ] on: Error do: [ '' ].
        safePosition := [ aContext position ifNil: [ 0 ] ] on: Error do: [ 0 ].
        safePosition := (safePosition max: 0) min: safeSource size.
        ^ Dictionary new
                        at: #prefix put: (safePosition > 0 ifTrue: [ safeSource copyFrom: 1 to: safePosition ] ifFalse: [ '' ]);
                        at: #suffix put: (safePosition < safeSource size
                                ifTrue: [ safeSource copyFrom: safePosition + 1 to: safeSource size ]
                                ifFalse: [ '' ]);
                        at: #position put: safePosition;
                        at: #sourceLength put: safeSource size;
                        yourself
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> debounceMilliseconds [

	^ debounceMilliseconds ifNil: [ 250 ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> debounceMilliseconds: anInteger [

        debounceMilliseconds := anInteger
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> indexOfClosingFenceIn: text startingAt: startIndex [ 

        | idx lastValid size |
        text isEmpty ifTrue: [ ^ 0 ].
        size := text size.
        lastValid := 0.
        idx := text indexOfSubCollection: '```' startingAt: startIndex ifAbsent: [ 0 ].
        [ idx > 0 ] whileTrue: [
                | before after |
                before := idx = 1 or: [
                        | prev |
                        prev := text at: idx - 1.
                        prev = Character lf or: [ prev = Character cr ] ].
                after := (idx + 3 > size)
                        or: [ | next |
                                next := text at: idx + 3.
                                next = Character lf or: [ next = Character cr ] ].
                (before and: after) ifTrue: [ lastValid := idx ].
                idx := text indexOfSubCollection: '```' startingAt: idx + 1 ifAbsent: [ 0 ].
        ].
        ^ lastValid
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> initialize [

	super initialize.
	debounceMilliseconds := 250.
	debounceToken := 0.
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> initializeOnContext: aSystemCompletionContext [

	completionContext := aSystemCompletionContext.
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> isLanguageSpec: aString [

	        | candidate trimmed |
        aString ifNil: [ ^ false ].
        candidate := aString asString.
        candidate isEmpty ifTrue: [ ^ false ].
        trimmed := candidate trimBoth.
        (trimmed size = candidate size) ifFalse: [ ^ false ].
        candidate := trimmed.
        ^ (#('smalltalk' 'pharo' 'bash' 'sh' 'shell' 'python'
                'javascript' 'json' 'java' 'c' 'cpp' 'xml' 'html'
                'ruby' 'php' 'sql' 'yaml' 'yml' 'go' 'rust' 'typescript')
                includes: candidate asLowercase)
                or: [ candidate allSatisfy: [ :ch |
                                ch isLetter
                                        or: [ ch isDigit
                                        or: [ '#+-_' includes: ch ] ] ] ]
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> methodSourcesFor: aBehavior [

        aBehavior ifNil: [ ^ '' ].
        ^ String streamContents: [ :stream |
                [ (aBehavior selectors asSortedCollection) do: [ :selector |
                        | source |
                        source := [ aBehavior sourceCodeAt: selector ] on: Error do: [ nil ].
                        source ifNotNil: [
                                stream
                                        nextPutAll: source;
                                        cr;
                                        cr ] ] ]
                        on: Error
                        do: [ ] ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> minimumPrefixLength [

        ^ 2
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> processCompletionFor: aContext prefix: prefixString suffix: suffixString contextInfo: contextInfo [

	| classContext |
	[
		| client rawResponse rawResponseString content |

		client := OllamaClient new.
		classContext := self classContextFor: aContext.
		contextInfo
			at: #classContextLength put: classContext size;
			at: #classContextPresent put: classContext isEmpty not.
		rawResponse := client generateForPrefix: prefixString suffix: suffixString context: classContext.
		rawResponseString := [ rawResponse asString ]
			                     on: Error
			                     do: [ rawResponse printString ].
		contextInfo at: #rawResponse put: rawResponseString.


		content := rawResponseString.
		[
			| parsed |
			parsed := STONJSON fromString: rawResponseString.
			(parsed isKindOf: Dictionary) ifTrue: [
				content := parsed at: #response ifAbsent: [ parsed at: 'response' ifAbsent: [ rawResponseString ] ] ] ]
			on: Error
			do: [ :ex |
				].

		content := self cleanedContentFrom: content asString.
		self
			applyContent: content
			toContext: aContext
			expectedPrefix: prefixString
			suffix: suffixString
			contextInfo: contextInfo ]
		on: Error
		do: [ :ex |
				 ]
]

{ #category : 'API - building' }
CoPharoCopilotResultSetBuilder >> safeDefinitionStringFor: aBehavior [

        aBehavior ifNil: [ ^ '' ].
        ^ [ aBehavior definition asString ] on: Error do: [ '' ]
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> scheduleCompletionFor: aContext prefix: prefixString suffix: suffixString contextInfo: contextInfo [

	| token |
	debounceToken ifNil: [ debounceToken := 0 ].
	debounceToken := debounceToken + 1.
	token := debounceToken.
	debounceProcess ifNotNil: [ debounceProcess terminate ].
	debounceProcess := [
		                   (Delay forMilliseconds: self debounceMilliseconds) wait.
		                   token = debounceToken ifTrue: [
				                   self
					                   processCompletionFor: aContext
					                   prefix: prefixString
					                   suffix: suffixString
					                   contextInfo: contextInfo ] ] forkAt: Processor userBackgroundPriority.
	^ self
]

{ #category : 'initialization' }
CoPharoCopilotResultSetBuilder >> shouldRequestCompletionForPrefix: prefixString suffix: suffixString [

        prefixString ifNil: [ ^ false ].
        (prefixString size < self minimumPrefixLength) ifTrue: [ ^ false ].
        ^ true
]
